# Acquiring data related to the Syriac Gazetteer (syriaca.org)

Linked Data Working Group 2018-11-12

## About the Syriac Gazetteer

The [Syriac Gazetteer](http://syriaca.org/) is a digital reference portal for information about historical Syriac places, people, and literature.  For example, places such as Edessa (the city, not the stink bug) have web pages like http://syriaca.org/place/78.html that allow humans to browse.  

The syriaca.org data are also available as Linked Open Data (LOD), and they can be accessed via a SPARQL endpoint GUI at http://wwwb.library.vanderbilt.edu/sparql/index.html or via HTTP at http://wwwb.library.vanderbilt.edu/api/sparql .

Because the syriaca.org data are LOD, they have been aggregated by other providers, such as http://peripleo.pelagios.org/ . The Peripleo [page for Edessa](http://peripleo.pelagios.org/ui#selected=http%3A%2F%2Fpleiades.stoa.org%2Fplaces%2F658457) has a "Linked Data View" that shows the data sources (including syriaca.org) that it has aggregated.  Thus it is possible that there are linked data known to Peripleo that are not present in the syriaca.org dataset.  Our goal is to discover those data and possibly retrieve them for incorporation into the syriaca.org dataset.

## Acquiring the Pleiades identifiers for syriaca.org places

In order to retrieve records from Peripleo, we need to know the Pleiades identifiers that correspond to syriaca.org place records.  There is a diagram of the syriaca.org graph model in our working group's [SPARQL endpoint User Guide](https://github.com/HeardLibrary/semantic-web/blob/master/sparql/syriaca.md).  (Note that the entire syriaca.org RDF dataset is not present in our triplestore and that the place data there are not up to date.)  The property linking the syriaca.org URI to the Pleiades URI is `skos:closeMatch`. Here is a SPARQL query that will retrieve the Pleiades URIs from the syriaca.org SPARQL endpoint:

```
prefix skos: <http://www.w3.org/2004/02/skos/core#>
SELECT DISTINCT ?s ?object
WHERE {
?s skos:closeMatch ?object.
?s a <http://lawd.info/ontology/Place>.
FILTER(STRSTARTS(str(?object),"http://pleiades.stoa.org/places/"))
}
```

The syriaca.org SPARQL endpoint does not support requests for results in CSV form, so to create a table relating the two related URIs, it is necessary to copy and paste from the GUI results, or use this BaseX/XQuery script:

```
declare namespace skos = "http://www.w3.org/2004/02/skos/core#";
declare default element namespace "http://www.w3.org/2005/sparql-results#";

declare function local:query-endpoint($endpoint as xs:string)
{
let $acceptType := "application/xml"
let $request := <http:request href='{$endpoint}' method='get'><http:header name='Accept' value='{$acceptType}'/></http:request>
return http:send-request($request)
};

file:write("c:\temp\syriaca-pleiades.csv",

    let $query := '
prefix skos: <http://www.w3.org/2004/02/skos/core#>
SELECT DISTINCT ?s ?object
WHERE {
?s skos:closeMatch ?object.
?s a <http://lawd.info/ontology/Place>.
FILTER(STRSTARTS(str(?object),"http://pleiades.stoa.org/places/"))
}   
'

    let $endpoint := 'http://wwwb.library.vanderbilt.edu/api/sparql?query='
    let $fullUri := $endpoint||web:encode-url($query)
    let $httpResults := local:query-endpoint($fullUri)[2]
    return ('syriaca_place,pleiades_place&#10;',
    for $result in $httpResults//result
    return $result/binding[@name='s']/uri/text()||','||$result/binding[@name='object']/uri/text()||'&#10;'
           )
)
```

Notes:
1. Although the Accept: header in the script could be edited to request various serializations, the type returned is always text/xml.  
2. For easy readability, the results were output as CSV.  However, the returned XML could have just been saved and used directly in the next step of the processing.

The output of this step is [here](syriaca/syriaca-pleiades.csv).

## Acquiring data from the Peripleo API

Peripleo has an API that can be used to retrieve data about a number of kinds of resources.  The v.2 API does not have documentation.  However, looking at the [v.1 API documentation](https://github.com/pelagios/peripleo/blob/master/README.md), we can find the REST method we need (`/peripleo/places/{uri}`).  

To retrieve data from the API about a Pelagios resource, the base URI `http://peripleo.pelagios.org/peripleo/places/` is concatenated with the URL encoded URI of the Pelagios resource.  An example resource from our CSV file is the record for Ctesiphon (http://syriaca.org/place/58), which has the Pelagios URI http://pleiades.stoa.org/places/893976.  That URI can be URL encoded using a tool like https://meyerweb.com/eric/tools/dencoder/, which results in the encoded URL `http%3A%2F%2Fpleiades.stoa.org%2Fplaces%2F893976`. So the concatenated URI for the API call is

```
http://peripleo.pelagios.org/peripleo/places/http%3A%2F%2Fpleiades.stoa.org%2Fplaces%2F893976
```

Putting this URI in a browser will show you the JSON that the API returns when you make the API call.  The Peripleo API does not provide any alternative serializations such as XML, nor does it offer RDF in any serialization.  However, one can use BaseX/XQuery to transform the JSON into RDF/XML.

We can let BaseX do its default conversion from JSON to XML. When BaseX loads the JSON, the resulting XML looks like this (with many elements omitted as ...):

```
<json type="object">
  <identifier>http://pleiades.stoa.org/places/894084</identifier>
  <title>Veh Ardashir/Coche/Mahoza/‘Seleucia’</title>
  <object__type>Place</object__type>
  <description>Seleucia/Sliq Kharawta was a city founded on the Tigris river by Seleukos I Nikator.</description>
  <names type="array">
    <_>Seleucia</_>
    <_>Sliq Kharawta</_>
    <_>Σελεύκεια</_>
    ...
  </names>
  <matches type="array">
    <_>http://pleiades.stoa.org/places/894178</_>
    <_>http://dare.ht.lu.se/places/25278</_>
    <_>http://dare.ht.lu.se/places/21867</_>
    <_>http://topostext.org/place/331445USel</_>
    ...
  </matches>
  <geo__bounds type="object">
    <min__lon type="number">44.523106</min__lon>
    <max__lon type="number">44.523106</max__lon>
    <min__lat type="number">33.095833</min__lat>
    <max__lat type="number">33.095833</max__lat>
  </geo__bounds>
  <geometry type="object">
    <type>Point</type>
    <coordinates type="array">
      <_ type="number">44.523106</_>
      <_ type="number">33.095833</_>
    </coordinates>
  </geometry>
  <network type="object">
    <edges type="array">
      <_ type="object">
        <source type="number">0</source>
        <target type="number">14</target>
        <is__inner__edge type="boolean">true</is__inner__edge>
      </_>
      <_ type="object">
        <source type="number">0</source>
        <target type="number">15</target>
        <is__inner__edge type="boolean">true</is__inner__edge>
      </_>
      ...
    </edges>
    <nodes type="array">
      <_ type="object">
        <uri>http://dare.ht.lu.se/places/25278</uri>
        <label>Veh Ardashir/Coche/Mahoza/‘Seleucia’, Tell Baruda</label>
        <is__inner__node type="boolean">true</is__inner__node>
      </_>
      <_ type="object">
        <uri>http://dare.ht.lu.se/places/21867</uri>
        <label>Seleucia/Sliq Kharawta, Tell Omar</label>
        <is__inner__node type="boolean">true</is__inner__node>
      </_>
      <_ type="object">
        <uri>http://topostext.org/place/331445USel</uri>
        <label>Seleukeia (Mesopotamia)</label>
        <is__inner__node type="boolean">true</is__inner__node>
      ...
      <_ type="object">
        <uri>http://www.livius.org/place/seleucia-on-the-tigris</uri>
        <is__inner__node type="boolean">false</is__inner__node>
      </_>
      <_ type="object">
        <uri>http://www.csc.org.il/db/browse.aspx?db=SB&amp;sL=K&amp;sK=Kokhe&amp;sT=keywords</uri>
        <is__inner__node type="boolean">false</is__inner__node>
      </_>
      ...
    </nodes>
  </network>
  <referenced__in type="array">
    <_ type="object">
      <title>American Numismatic Society</title>
      <identifier>http://numismatics.org/search</identifier>
      <count type="number">560</count>
      <peripleo__url>http://peripleo.pelagios.org/ui#referencing=http://pleiades.stoa.org/places/894084&amp;datasets=http://numismatics.org/search&amp;filters=true</peripleo__url>
    </_>
    <_ type="object">
      <title>Nomisma.org Partner Objects</title>
      <identifier>http://nomisma.org/#objects</identifier>
      <count type="number">18</count>
      <peripleo__url>http://peripleo.pelagios.org/ui#referencing=http://pleiades.stoa.org/places/894084&amp;datasets=http://nomisma.org/#objects&amp;filters=true</peripleo__url>
    </_>
    <_ type="object">
      <title>PELLA</title>
      <identifier>http://numismatics.org/pella</identifier>
      <count type="number">8</count>
      <peripleo__url>http://peripleo.pelagios.org/ui#referencing=http://pleiades.stoa.org/places/894084&amp;datasets=http://numismatics.org/pella&amp;filters=true</peripleo__url>
    </_>
    <_ type="object">
      <title>The Fralin | UVa Art Museum Numismatic Collection</title>
      <identifier>node1c6eve1cdx1</identifier>
      <count type="number">1</count>
      <peripleo__url>http://peripleo.pelagios.org/ui#referencing=http://pleiades.stoa.org/places/894084&amp;datasets=node1c6eve1cdx1&amp;filters=true</peripleo__url>
    </_>
  </referenced__in>
</json>
```

Here's the steps to do the scrape:

1. Open the CSV file we made earlier and find out how many pairs of URIs there are (lines 46 to 48):
```
let $textPleiadesUris := file:read-text('file:///c:/temp/syriaca-pleiades.csv')
let $xmlPleiadesUris := csv:parse($textPleiadesUris, map { 'header' : true(),'separator' : "," })
let $numberOfResults := count($xmlPleiadesUris/csv/record)
```

2. Step through each pair and assign the URIs to variables (lines 54 to 57):
```
for $record in (1 to $numberOfResults)
let $uri := $xmlPleiadesUris/csv/record[$record]/pleiades_place/text()
let $syriacaId := $xmlPleiadesUris/csv/record[$record]/syriaca_place/text()
```

3. URL-encode the Pelagios URI and concatenate it to the API URL (line 58):
```
let $fullUri := 'http://peripleo.pelagios.org/peripleo/places/'||web:encode-url($uri)
```

4. Make the HTTP GET request and pull out the results element (the 2nd one; ignore the first header element; line 59):
```
let $results := local:query-endpoint($fullUri)[2]
```

5. Lines 61 to 101 insert various bits of the $results (by way of their XPath expressions) into an RDF/XML template.

6. The entire blob of RDF/XML is written to the a file using the file:write function (lines 52 and 103):
```
file:write("c:\test\syriaca-pleiades.rdf",
[RDF/XML blob]
)
```

The entire script can be viewed [here](syriaca/pelagios-get.xq)
